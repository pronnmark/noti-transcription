import { NextRequest, NextResponse } from 'next/server';
import { getSupabase } from '@/lib/database/client';
import { telegramMCP } from '@/lib/services/telegram-mcp-client';
import {
  getSessionTokenFromRequest,
  unauthorizedResponse,
} from '@/lib/auth-server';

export async function POST(request: NextRequest) {
  try {
    // Check authentication
    const sessionToken = getSessionTokenFromRequest(request);
    if (!sessionToken) {
      return unauthorizedResponse();
    }

    const {
      fileId,
      chatId,
      username,
      groupName,
      summaryType = 'latest',
    } = await request.json();

    if (!fileId) {
      return NextResponse.json(
        { success: false, error: 'Missing required field: fileId' },
        { status: 400 }
      );
    }

    if (!chatId && !username && !groupName) {
      return NextResponse.json(
        {
          success: false,
          error: 'Must provide either chatId, username, or groupName',
        },
        { status: 400 }
      );
    }

    const supabase = getSupabase();

    // Get file details
    const { data: file, error: fileError } = await supabase
      .from('audio_files')
      .select('*')
      .eq('id', fileId)
      .single();

    if (fileError || !file) {
      return NextResponse.json(
        { success: false, error: 'File not found' },
        { status: 404 }
      );
    }

    // Get summarization
    const { data: summary, error: summaryError } = await supabase
      .from('summarizations')
      .select(
        `
        *,
        summarization_prompts (
          name,
          description
        )
      `
      )
      .eq('file_id', fileId)
      .order('created_at', { ascending: false })
      .limit(1)
      .single();

    if (summaryError || !summary) {
      return NextResponse.json(
        { success: false, error: 'No summary found for this file' },
        { status: 404 }
      );
    }

    // Format the summary message
    const fileName = file.original_file_name || file.file_name;
    const duration = file.duration ? formatDuration(file.duration) : 'Unknown';
    const templateInfo = summary.summarization_prompts?.name
      ? ` (${summary.summarization_prompts.name})`
      : '';
    const createdDate = new Date(summary.created_at).toLocaleDateString();

    const message = `ğŸ“ **Summary${templateInfo}**
File: ${fileName}
Duration: ${duration}
Date: ${createdDate}

${summary.content}

---
_Generated by Noti AI_`;

    // Determine the target for sending
    let targetChatId = chatId;

    if (!targetChatId) {
      if (username) {
        // Resolve username to chat ID
        targetChatId = await telegramMCP.resolveUsername(username);
      } else if (groupName) {
        // For groups, we'd need to resolve the group name
        // This might require additional implementation in telegram-mcp
        return NextResponse.json(
          {
            success: false,
            error: 'Group name resolution not yet implemented',
          },
          { status: 501 }
        );
      }
    }

    if (!targetChatId) {
      return NextResponse.json(
        { success: false, error: 'Could not resolve target chat' },
        { status: 400 }
      );
    }

    // Send the message
    await telegramMCP.sendMessage(targetChatId, message);

    return NextResponse.json({
      success: true,
      message: 'Summary shared successfully',
      details: {
        fileId,
        fileName,
        targetChatId,
        summaryType: 'summarization',
      },
    });
  } catch (error) {
    console.error('Error sharing summary:', error);
    return NextResponse.json(
      {
        success: false,
        error: 'Failed to share summary',
        details: error instanceof Error ? error.message : String(error),
      },
      { status: 500 }
    );
  }
}

function formatDuration(seconds: number): string {
  const hours = Math.floor(seconds / 3600);
  const minutes = Math.floor((seconds % 3600) / 60);
  const secs = Math.floor(seconds % 60);

  if (hours > 0) {
    return `${hours}h ${minutes}m ${secs}s`;
  } else if (minutes > 0) {
    return `${minutes}m ${secs}s`;
  } else {
    return `${secs}s`;
  }
}
