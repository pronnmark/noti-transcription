import { NextRequest, NextResponse } from 'next/server';
import { db } from '@/lib/database';
import { telegramSettings, telegramShares, audioFiles } from '@/lib/database/schema';
import { eq } from 'drizzle-orm';
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

export async function POST(request: NextRequest) {
  try {
    const { fileId, summarizationId, content, fileName, chatId } = await request.json();

    if (!fileId || !content || !fileName) {
      return NextResponse.json(
        { success: false, error: 'Missing required fields: fileId, content, fileName' },
        { status: 400 }
      );
    }

    // Get Telegram settings from database or use env fallbacks
    const settings = await db.select().from(telegramSettings).limit(1);
    const telegramConfig = settings[0];

    // Determine bot token (DB or env fallback)
    const botToken = telegramConfig?.botToken || process.env.TELEGRAM_BOT_TOKEN;
    if (!botToken) {
      return NextResponse.json(
        { success: false, error: 'No Telegram bot token configured' },
        { status: 400 }
      );
    }

    // Determine target chat ID
    let targetChatId = chatId;
    if (!targetChatId) {
      targetChatId = telegramConfig?.defaultChatId || process.env.TELEGRAM_DEFAULT_CHAT_ID;
    }
    
    if (!targetChatId) {
      return NextResponse.json(
        { success: false, error: 'No target chat ID specified' },
        { status: 400 }
      );
    }

    // Format message for Telegram
    const message = `🎙️ **Audio Summary**
📁 ${fileName}

${content}

Generated by Noti Audio Transcription`;

    // Record the share attempt
    const [shareRecord] = await db.insert(telegramShares).values({
      fileId,
      summarizationId,
      chatId: targetChatId,
      chatName: getChatName(telegramConfig, targetChatId),
      messageText: message,
      status: 'pending',
    }).returning();

    try {
      // Send message via Telegram MCP container
      // Escape quotes and newlines for shell execution
      const escapedMessage = message.replace(/'/g, "\\'").replace(/\n/g, '\\n');
      
      const command = `docker exec telegram-mcp-container python -c "
import sys
sys.path.append('/app')
from main import send_message
try:
    result = send_message(${targetChatId}, '''${escapedMessage}''')
    print('SUCCESS')
except Exception as e:
    print(f'ERROR: {str(e)}')
    sys.exit(1)
"`;

      const { stdout, stderr } = await execAsync(command);
      
      if (stderr && !stdout.includes('SUCCESS')) {
        throw new Error(stderr);
      }

      // Update share record as successful
      await db.update(telegramShares)
        .set({ 
          status: 'sent',
          telegramMessageId: 'unknown', // Telegram MCP doesn't return message ID
        })
        .where(eq(telegramShares.id, shareRecord.id));

      return NextResponse.json({
        success: true,
        shareId: shareRecord.id,
        message: 'Summary shared to Telegram successfully'
      });

    } catch (error) {
      // Update share record as failed
      await db.update(telegramShares)
        .set({ 
          status: 'failed',
          error: error instanceof Error ? error.message : 'Unknown error'
        })
        .where(eq(telegramShares.id, shareRecord.id));

      return NextResponse.json(
        { success: false, error: `Failed to send message: ${error}` },
        { status: 500 }
      );
    }

  } catch (error) {
    console.error('Telegram share error:', error);
    return NextResponse.json(
      { success: false, error: 'Internal server error' },
      { status: 500 }
    );
  }
}

// Helper function to get chat name from configuration
function getChatName(config: any, chatId: string): string {
  if (!config?.chatConfigurations) return 'Unknown Chat';
  
  const chat = config.chatConfigurations.find((c: any) => c.chatId === chatId);
  return chat?.name || 'Unknown Chat';
}