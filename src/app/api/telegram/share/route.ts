import { NextRequest, NextResponse } from 'next/server';
import { db } from '@/lib/database';
import { telegramSettings, telegramShares, audioFiles } from '@/lib/database/schema';
import { eq } from 'drizzle-orm';
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

export async function POST(request: NextRequest) {
  try {
    const { fileId, summarizationId, content, fileName, chatId } = await request.json();

    if (!fileId || !content || !fileName) {
      return NextResponse.json(
        { success: false, error: 'Missing required fields: fileId, content, fileName' },
        { status: 400 },
      );
    }

    // Get Telegram settings from database or use env fallbacks
    const settings = await db.select().from(telegramSettings).limit(1);
    const telegramConfig = settings[0];

    // Determine bot token (DB or env fallback)
    const botToken = telegramConfig?.botToken || process.env.TELEGRAM_BOT_TOKEN;
    if (!botToken) {
      return NextResponse.json(
        { success: false, error: 'No Telegram bot token configured' },
        { status: 400 },
      );
    }

    // Determine target chat ID
    let targetChatId = chatId;
    if (!targetChatId) {
      targetChatId = telegramConfig?.defaultChatId || process.env.TELEGRAM_DEFAULT_CHAT_ID;
    }

    if (!targetChatId) {
      return NextResponse.json(
        { success: false, error: 'No target chat ID specified' },
        { status: 400 },
      );
    }

    // Format message for Telegram with Markdown
    const message = `ðŸŽ™ï¸ **Audio Summary**
ðŸ“ ${fileName}

${content}

_Generated by Noti Audio Transcription_`;

    // Record the share attempt
    const [shareRecord] = await db.insert(telegramShares).values({
      fileId,
      summarizationId,
      chatId: targetChatId,
      chatName: getChatName(telegramConfig, targetChatId),
      messageText: message,
      status: 'pending',
    }).returning();

    try {
      // Enhanced docker exec command with better error handling
      const escapedMessage = message
        .replace(/\\/g, '\\\\')
        .replace(/"/g, '\\"')
        .replace(/`/g, '\\`')
        .replace(/\$/g, '\\$')
        .replace(/\n/g, '\\n');

      // Use JSON for safer parameter passing
      const command = `docker exec telegram-mcp-server python -c "
import sys
import json
import asyncio
from telethon import TelegramClient

async def send():
    try:
        # Initialize client from environment
        from main import client
        await client.connect()
        
        # Send message
        result = await client.send_message(${targetChatId}, '''${escapedMessage}''', parse_mode='Markdown')
        
        # Return success with message ID
        print(json.dumps({
            'success': True,
            'message_id': result.id,
            'chat_id': result.chat_id
        }))
    except Exception as e:
        print(json.dumps({
            'success': False,
            'error': str(e)
        }))
        sys.exit(1)

asyncio.run(send())
"`;

      const { stdout, stderr } = await execAsync(command);

      // Parse the JSON response
      let response;
      try {
        response = JSON.parse(stdout.trim());
      } catch (e) {
        // Fallback for non-JSON output
        if (stderr || !stdout) {
          throw new Error(stderr || 'No output from Telegram command');
        }
        response = { success: true, message_id: null };
      }

      if (!response.success) {
        throw new Error(response.error || 'Failed to send message');
      }

      // Update share record as successful
      await db.update(telegramShares)
        .set({
          status: 'sent',
          telegramMessageId: response.message_id ? String(response.message_id) : 'sent',
        })
        .where(eq(telegramShares.id, shareRecord.id));

      return NextResponse.json({
        success: true,
        shareId: shareRecord.id,
        message: 'Summary shared to Telegram successfully',
        telegramMessageId: response.message_id,
      });

    } catch (error) {
      // Update share record as failed
      await db.update(telegramShares)
        .set({
          status: 'failed',
          error: error instanceof Error ? error.message : 'Unknown error',
        })
        .where(eq(telegramShares.id, shareRecord.id));

      return NextResponse.json(
        { success: false, error: `Failed to send message: ${error}` },
        { status: 500 },
      );
    }

  } catch (error) {
    console.error('Telegram share error:', error);
    return NextResponse.json(
      { success: false, error: 'Internal server error' },
      { status: 500 },
    );
  }
}

// Helper function to get chat name from configuration
function getChatName(config: any, chatId: string): string {
  if (!config?.chatConfigurations) return 'Unknown Chat';

  const chat = config.chatConfigurations.find((c: any) => c.chatId === chatId);
  return chat?.name || 'Unknown Chat';
}
