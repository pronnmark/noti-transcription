import { NextRequest, NextResponse } from 'next/server';
import { getSupabase } from '@/lib/database/client';
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

export async function POST(request: NextRequest) {
  try {
    const { fileId, summarizationId, content, fileName, chatId } =
      await request.json();

    if (!fileId || !content || !fileName) {
      return NextResponse.json(
        {
          success: false,
          error: 'Missing required fields: fileId, content, fileName',
        },
        { status: 400 }
      );
    }

    // Get Telegram settings from database or use env fallbacks
    const supabase = getSupabase();
    const { data: settings } = await supabase
      .from('telegram_settings')
      .select('*')
      .limit(1);
    const telegramConfig = settings?.[0];

    // Determine bot token (DB or env fallback)
    const botToken =
      telegramConfig?.bot_token || process.env.TELEGRAM_BOT_TOKEN;
    if (!botToken) {
      return NextResponse.json(
        { success: false, error: 'No Telegram bot token configured' },
        { status: 400 }
      );
    }

    // Determine target chat ID
    let targetChatId = chatId;
    if (!targetChatId) {
      targetChatId =
        telegramConfig?.default_chat_id || process.env.TELEGRAM_DEFAULT_CHAT_ID;
    }

    if (!targetChatId) {
      return NextResponse.json(
        { success: false, error: 'No target chat ID specified' },
        { status: 400 }
      );
    }

    // Format message for Telegram with Markdown
    const message = `🎙️ **Audio Summary**
📁 ${fileName}

${content}

_Generated by Noti Audio Transcription_`;

    // Record the share attempt
    const { data: shareRecord, error: insertError } = await supabase
      .from('telegram_shares')
      .insert({
        file_id: fileId,
        summarization_id: summarizationId,
        chat_id: targetChatId,
        chat_name: getChatName(telegramConfig, targetChatId),
        message_text: message,
        status: 'pending',
      })
      .select()
      .single();

    if (insertError) {
      throw insertError;
    }

    try {
      // Enhanced docker exec command with better error handling
      const escapedMessage = message
        .replace(/\\/g, '\\\\')
        .replace(/"/g, '\\"')
        .replace(/`/g, '\\`')
        .replace(/\$/g, '\\$')
        .replace(/\n/g, '\\n');

      // Use JSON for safer parameter passing
      const command = `docker exec telegram-mcp-server python -c "
import sys
import json
import asyncio
from telethon import TelegramClient

async def send():
    try:
        # Initialize client from environment
        from main import client
        await client.connect()
        
        # Send message
        result = await client.send_message(${targetChatId}, '''${escapedMessage}''', parse_mode='Markdown')
        
        # Return success with message ID
        print(json.dumps({
            'success': True,
            'message_id': result.id,
            'chat_id': result.chat_id
        }))
    except Exception as e:
        print(json.dumps({
            'success': False,
            'error': str(e)
        }))
        sys.exit(1)

asyncio.run(send())
"`;

      const { stdout, stderr } = await execAsync(command);

      // Parse the JSON response
      let response;
      try {
        response = JSON.parse(stdout.trim());
      } catch (e) {
        // Fallback for non-JSON output
        if (stderr || !stdout) {
          throw new Error(stderr || 'No output from Telegram command');
        }
        response = { success: true, message_id: null };
      }

      if (!response.success) {
        throw new Error(response.error || 'Failed to send message');
      }

      // Update share record as successful
      await supabase
        .from('telegram_shares')
        .update({
          status: 'sent',
          telegram_message_id: response.message_id
            ? String(response.message_id)
            : 'sent',
        })
        .eq('id', shareRecord.id);

      return NextResponse.json({
        success: true,
        shareId: shareRecord.id,
        message: 'Summary shared to Telegram successfully',
        telegramMessageId: response.message_id,
      });
    } catch (error) {
      // Update share record as failed
      await supabase
        .from('telegram_shares')
        .update({
          status: 'failed',
          error: error instanceof Error ? error.message : 'Unknown error',
        })
        .eq('id', shareRecord.id);

      return NextResponse.json(
        { success: false, error: `Failed to send message: ${error}` },
        { status: 500 }
      );
    }
  } catch (error) {
    console.error('Telegram share error:', error);
    return NextResponse.json(
      { success: false, error: 'Internal server error' },
      { status: 500 }
    );
  }
}

// Helper function to get chat name from configuration
function getChatName(config: any, chatId: string): string {
  if (!config?.chat_configurations) return 'Unknown Chat';

  const chat = config.chat_configurations.find(
    (c: any) => c.chat_id === chatId
  );
  return chat?.name || 'Unknown Chat';
}
